/*───────────────────────────────────────────────
  Property of CKS  © 2025
───────────────────────────────────────────────*/
/**
 * File: useTabComponents.ts
 *
 * Description:
 * Uses the generated component manifest to provide
 * accurate component usage information
 *
 * Responsibilities:
 * - Load component manifest generated by analyzer
 * - Provide tab-specific component usage data
 * - Merge with discovered components for complete picture
 *
 * Role in system:
 * - Bridge between build-time analysis and runtime display
 *
 * Notes:
 * Requires running npm run analyze to update manifest
 */
/*───────────────────────────────────────────────
  Manifested by Freedom_EXE
───────────────────────────────────────────────*/

import { useState, useEffect } from 'react';
// Use the improved v2 manifest generated by scripts/analyze-components-v2.js
import componentManifestV2 from '../component-manifest-v2.json';
// Use the component registry (from discover-components) to surface child components
// that are used inside parent widgets (e.g., ActivityItem inside RecentActivity)
import componentRegistry from '../component-registry.json';

export interface TabComponentInfo {
  name: string;
  location: string;
  type: 'hub' | 'ui' | 'domain' | 'feature' | 'external';
  usedByTab: boolean;
  tabs: string[]; // Which tabs use this component
  count?: number; // How many times the component is used
}

// Build tab definitions from manifest
function buildRoleTabs() {
  const tabs: Record<string, { id: string; label: string }[]> = {};

  for (const [role, data] of Object.entries(componentManifestV2 as any)) {
    const roleData = data as any;
    const tabDefs = roleData.tabDefinitions || [];

    tabs[role] = tabDefs.map((tabId: string) => ({
      id: tabId,
      label: tabId.charAt(0).toUpperCase() + tabId.slice(1) // Capitalize first letter
    }));
  }

  return tabs;
}

// Tab definitions from actual hub files
export const roleTabs = buildRoleTabs();

export function useTabComponents(selectedRole: string, selectedTab: string | null) {
  const [allComponents, setAllComponents] = useState<TabComponentInfo[]>([]);
  const [tabComponents, setTabComponents] = useState<TabComponentInfo[]>([]);
  const [componentCount, setComponentCount] = useState({ total: 0, used: 0 });

  useEffect(() => {
    const discoverComponents = async () => {
      const components: TabComponentInfo[] = [];
      const componentMap = new Map<string, TabComponentInfo>();

      // Add the hub component itself
      const hubName = `${selectedRole.charAt(0).toUpperCase() + selectedRole.slice(1)}Hub`;
      const hubComponent: TabComponentInfo = {
        name: hubName,
        location: `frontend/src/hubs/${hubName}.tsx`,
        type: 'hub',
        usedByTab: true,
        tabs: (roleTabs[selectedRole] || []).map(t => t.id),
        count: 1
      };
      components.push(hubComponent);
      componentMap.set(hubName, hubComponent);

      // Get component usage from improved v2 manifest
      const roleManifest = (componentManifestV2 as any)[selectedRole];
      const tabsUsage = roleManifest?.tabs || {};

      // Build a complete component list from all tabs
      const allComponentsFromManifest = new Map<string, any>();

      for (const [tabId, tabComps] of Object.entries<any>(tabsUsage as any)) {
        for (const [compName, compInfo] of Object.entries<any>(tabComps as any)) {
          if (!allComponentsFromManifest.has(compName)) {
            allComponentsFromManifest.set(compName, {
              ...(compInfo as Record<string, unknown>),
              usedInTabs: new Set([tabId]),
              totalCount: (compInfo as any).count || 1
            });
          } else {
            const existing = allComponentsFromManifest.get(compName);
            existing.usedInTabs.add(tabId);
            existing.totalCount += (compInfo as any).count || 1;
          }
        }
      }

      // Augment with registry usage to include child components (e.g., ActivityItem)
      try {
        const reg: any = componentRegistry as any;
        const roleReg = reg?.hubs?.[selectedRole];
        const registryIndexByName = new Map<string, any>();
        for (const comp of (reg?.components || [])) {
          registryIndexByName.set(comp.name, comp);
        }

        if (roleReg?.components) {
          for (const [compName, usage] of Object.entries(roleReg.components)) {
            const info = registryIndexByName.get(compName);
            const type = info?.type ?? 'feature';
            const path = info?.path;
            const tabsList: string[] = Array.isArray((usage as any).tabs)
              ? (usage as any).tabs
              : (roleReg.tabs || []);
            const count = (usage as any).count ?? 1;

            if (!allComponentsFromManifest.has(compName)) {
              allComponentsFromManifest.set(compName, {
                type,
                path,
                usedInTabs: new Set(tabsList),
                totalCount: count
              });
            } else {
              const existing = allComponentsFromManifest.get(compName);
              tabsList.forEach(t => existing.usedInTabs.add(t));
              existing.totalCount += count;
              // Prefer known type/path if missing
              if (!existing.type && type) existing.type = type;
              if (!existing.path && path) existing.path = path;
            }
          }
        }
      } catch (e) {
        // Non-fatal; continue without registry augmentation
        console.warn('Registry augmentation skipped:', e);
      }

      // Convert manifest components to TabComponentInfo
      for (const [compName, compData] of allComponentsFromManifest.entries()) {
        if (!componentMap.has(compName)) {
          const tabsList: string[] = Array.from(compData.usedInTabs as Set<string>) as string[];
          const isUsedInSelectedTab = !selectedTab || selectedTab === 'all' || tabsList.includes(selectedTab);

          const component: TabComponentInfo = {
            name: compName,
            location: compData.path?.replace('../../../', '') || `packages/${compData.type || 'feature'}/${compName}`,
            type: (compData.type as any) ?? 'feature',
            usedByTab: isUsedInSelectedTab,
            tabs: tabsList,
            count: (selectedTab && selectedTab !== 'all' && tabsUsage[selectedTab])
              ? (tabsUsage[selectedTab] as any)[compName]?.count || 0
              : compData.totalCount
          };
          components.push(component);
          componentMap.set(compName, component);
        }
      }

      // Also discover all available components from packages
      try {
        // Discover UI components
        const uiModules = import.meta.glob(['../../../packages/ui/src/**/*.tsx', '!../../../packages/ui/src/**/*.test.tsx', '!../../../packages/ui/src/**/*.stories.tsx'], { eager: false });

        for (const path of Object.keys(uiModules)) {
          if (path.includes('.test.') || path.includes('.stories.')) continue;

          const cleanPath = path.replace('../../../packages/ui/src/', '');
          const parts = cleanPath.split('/');
          const fileName = parts[parts.length - 1].replace('.tsx', '');

          let componentName = '';
          let componentPath = cleanPath;

          if (parts.length >= 2) {
            const folderName = parts[parts.length - 2];
            if (fileName === folderName || fileName === 'index') {
              componentName = folderName;
              componentPath = parts.slice(0, -1).join('/');
            } else {
              componentName = fileName;
              componentPath = cleanPath.replace('.tsx', '');
            }
          } else {
            componentName = fileName === 'index' ? 'Root' : fileName;
            componentPath = cleanPath.replace('.tsx', '');
          }

          if (componentName && componentName !== 'index' && !componentMap.has(componentName)) {
            const usedInManifest = allComponentsFromManifest.has(componentName);
            const component: TabComponentInfo = {
              name: componentName,
              location: `packages/ui/src/${componentPath}`,
              type: 'ui',
              usedByTab: usedInManifest,
              tabs: usedInManifest ? Array.from(allComponentsFromManifest.get(componentName).usedInTabs) : [],
              count: 0
            };
            components.push(component);
            componentMap.set(componentName, component);
          }
        }

        // Discover Domain components
        const domainModulesSrc = import.meta.glob(['../../../packages/domain-widgets/src/**/*.tsx', '!../../../packages/domain-widgets/src/**/*.test.tsx', '!../../../packages/domain-widgets/src/**/*.stories.tsx'], { eager: false });
        const domainModulesRoot = import.meta.glob(['../../../packages/domain-widgets/*.tsx', '!../../../packages/domain-widgets/*.test.tsx', '!../../../packages/domain-widgets/*.stories.tsx'], { eager: false });

        const allDomainModules = {
          ...domainModulesSrc,
          ...domainModulesRoot
        };

        for (const path of Object.keys(allDomainModules)) {
          if (path.includes('.test.') || path.includes('.stories.')) continue;

          const cleanPath = path.replace('../../../packages/domain-widgets/', '').replace('src/', '');
          const parts = cleanPath.split('/');
          const fileName = parts[parts.length - 1].replace('.tsx', '');

          let componentName = '';
          let componentPath = cleanPath;

          if (parts.length >= 2) {
            const folderName = parts[parts.length - 2];
            if (fileName === folderName || fileName === 'index') {
              componentName = folderName;
              componentPath = parts.slice(0, -1).join('/');
            } else {
              componentName = fileName;
              componentPath = cleanPath.replace('.tsx', '');
            }
          } else {
            componentName = fileName === 'index' ? 'Root' : fileName;
            componentPath = cleanPath.replace('.tsx', '');
          }

          if (componentName && componentName !== 'index' && !componentMap.has(componentName)) {
            const usedInManifest = allComponentsFromManifest.has(componentName);
            const component: TabComponentInfo = {
              name: componentName,
              location: `packages/domain-widgets/${componentPath.startsWith('src/') ? componentPath : 'src/' + componentPath}`,
              type: 'domain',
              usedByTab: usedInManifest,
              tabs: usedInManifest ? Array.from(allComponentsFromManifest.get(componentName).usedInTabs) : [],
              count: 0
            };
            components.push(component);
            componentMap.set(componentName, component);
          }
        }

      } catch (error) {
        console.error('Error discovering components:', error);
      }

      setAllComponents(components);

      // Filter for current tab
      const currentTabComponents = components.filter(comp => {
        if (!selectedTab || selectedTab === 'all') {
          return comp.tabs.length > 0;
        }
        return comp.tabs.includes(selectedTab);
      });

      setTabComponents(currentTabComponents);

      // Count components
      const usedCount = components.filter(c => c.usedByTab).length;
      setComponentCount({
        total: components.length,
        used: usedCount
      });
    };

    discoverComponents();
  }, [selectedRole, selectedTab]);

  return { allComponents, tabComponents, componentCount };
}
